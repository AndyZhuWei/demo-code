1.EagerSingleton、EagerSingleton2、EagerSingleton3这三种写法本质上其实是一样的。
但使用静态final的实例对象或者使用静态代码块依旧不能解决在反序列化、反射、克隆时重新生成实例对象的问题。

序列化：一是可以将一个单例的实例对象写到磁盘，实现数据的持久化；二是实现对象数据的远程传输。
       当单例对象有必要实现 Serializable 接口时，即使将其构造函数设为私有，在它反序列化时依然会通过特殊的途径再创建类的一个新的实例，
       相当于调用了该类的构造函数有效地获得了一个新实例！

反射：可以通过setAccessible(true)来绕过 private 限制，从而调用到类的私有构造函数创建对象。

克隆：clone()是 Object 的方法，每一个对象都是 Object 的子类，都有clone()方法。
      clone()方法并不是调用构造函数来创建对象，而是直接拷贝内存区域。因此当我们的单例对象实现了 Cloneable 接口时，尽管其构造函数是私有的，
      仍可以通过克隆来创建一个新对象，单例模式也相应失效了。

优点：写法比较简单，在类装载的时候就完成实例化。避免了线程同步问题。
缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。
那么我们就要考虑懒加载的问题了。

2.LazySingleton2
优点：懒加载，只有使用的时候才会加载。
缺点：但是只能在单线程下使用。如果在多线程下，instacnce对象还是空，
这时候两个线程同时访问getInstance()方法，因为对象还是空，所以两个线程同时通过了判断，开始执行new的操作。所以在多线程环境下不可使用这种方式。

3.LazySingleton

优点：懒加载，只有使用的时候才会加载，获取单例方法加了同步锁，保正了线程安全。
缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。

4.LazySingleton3
优点：改进了LazySingleton效率低的问题。
缺点：但实际上这个写法还不能保证线程安全，和LazySingleton2写法类似，只要两个线程同时进入了 if (singleton == null) { 这句判断，照样会进行两次new操作
接下来就是听起来很牛逼的双重检测加锁的单例模式。

5.LazySingleton4
本例的亮点都在getInstance()方法上，可以看到在该方法中对instance进行了两次判空：第一层判断为了避免不必要的同步，第二层判断则是为了在null的情况下创建实例。
对LazySingleton3单例的漏洞进行了弥补，但是还是有丶小问题的，问题就在instance = new Singleton();语句上。
这语句在这里看起来是一句代码啊，但实际上它并不是一个原子操作，这句代码最终会被编译成多条汇编指令，它大致做了3件事情：
给Singleton的实例分配内存
调用Singleton()的 构造函数，初始化成员字段
将instance对象指向分配的内存空间（此时instance就不是null了）

但是，由于Java编译器运行处理器乱序执行，以及jdk1.5之前Java内存模型中Cache、寄存器到主内存会写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，
执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行3了，
instance已经是非null，所有线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的问题很可能会隐藏很久。

优点：线程安全；延迟加载；效率较高。
缺点：JVM编译器的指令重排导致单例出现漏洞。

6 Singleton2
在jdk1.5之后，官方已经注意到这种问题，调整了JVM、具体化了volatile关键字，因此，如果是1.5或之后的版本，
只需要将instance的定义改成private static volatile Singleton instance = null;
就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile多少会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。
优点：线程安全；延迟加载；效率较高。
缺点：由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，略微的性能降低，但除非你的代码在并发场景比较复杂或者低于JDK6版本下使用，否则，这种方式一般是能够满足需求的。

7.Singleton

这种方式跟饿汉式方式采用的机制类似，但又有不同。 两者都是采用了类装载的机制来保证初始化实例时只有一个线程。
不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化
，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
所以在这里，利用 JVM的 classloder 的机制来保证初始化 instance 时只有一个线程。JVM 在类初始化阶段会获取一个锁，这个锁可以同步多个线程对同一个类的初始化
优点：避免了线程不安全，延迟加载，效率高。
缺点：依旧不能解决在反序列化、反射、克隆时重新生成实例对象的问题。

8.Singleton3
枚举类单例模式是《Effective Java》作者 Josh Bloch 极力推荐的单例方法
借助JDK 1.5中添加的枚举来实现单例模式。P.S. Enum是没有clone()方法的
1>.枚举类类型是 final 的「不可以被继承」
2>构造方法是私有的「也只能私有，不允许被外部实例化，符合单例」
3>类变量是静态的
4>没有延时初始化，随着类的初始化就初始化了「从上面静态代码块中可以看出」
5>由 4> 可以知道枚举也是线程安全的
优点：写法简单，不仅能避免多线程同步问题，而且还能防止反序列化、反射，克隆重新创建新的对象。
缺点：JDK 1.5之后才能使用。

P.S.  反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。
      为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定:
      在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。


9.EnumSingleton
 可以发现是因为EnumSingleton.class.getDeclaredConstructors()获取所有构造器，会发现并没有我们所设置的无参构造器，
只有一个参数为（String.class,int.class）构造器，然后看下Enum源码就明白，这两个参数是name和ordial两个属性
之前是因为没有无参构造器，这次拿到了父类的构造器了，还是在执行时候抛出异常，说是不能够反射
反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。

10.SerEnumSingleton
枚举类序列化例子
在反序列化的时候java.lang.Enum的valueOf方法会尝试从调用enumType这个Class对象的enumConstantDirectory()方法返回的map中获取名字为name的枚举对象，
如果不存在就会抛出异常。再进一步跟到enumConstantDirectory()方法，就会发现到最后会以反射的方式调用enumType这个类型的values()静态方法，
然后用返回结果填充enumType这个Class对象中的enumConstantDirectory属性

11.SingletonManger
查阅Android源码中的 LayoutInflater 对象就能发现使用了这种写法
优点：在程序的初始，将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象对应类型的对象。
这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作， 降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。
缺点：不常用，有些麻烦

12.EnumSingleton2 内部枚举类







