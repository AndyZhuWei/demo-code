# 课程介绍
![img.png](images/img.png)

#分布式事物应用场景

支付回调服务
![img_1.png](images/img_1.png)

下单业务
![img_2.png](images/img_2.png)


#事物的概念

## 什么是事务

![img_3.png](images/img_3.png)

## 事务特性以及实现方式
![img_4.png](images/img_4.png)
C和I是通过锁来实现的
A和D是通过日志来保证的（redo、undo日志）

以前JDBC时写事务的方法，分布式事务也有类似的写法
![img_5.png](images/img_5.png)

后来我们事务的写法
![img_6.png](images/img_6.png)


#分布式事物概念

![img_7.png](images/img_7.png)

![img_8.png](images/img_8.png)


#分布式事物思路分析

![img_9.png](images/img_9.png)

![img_10.png](images/img_10.png)

![img_11.png](images/img_11.png)


![img_12.png](images/img_12.png)


# XA规范

![img_13.png](images/img_13.png)

![img_14.png](images/img_14.png)

![img_15.png](images/img_15.png)

![img_16.png](images/img_16.png)


XA规范就类似JDBC规范，也有对应的数据库厂商进行实现。

![img_17.png](images/img_17.png)


#  2pc提交协议

![img_18.png](images/img_18.png)

![img_20.png](images/img_20.png)

![img_21.png](images/img_21.png)

![img_22.png](images/img_22.png)

![img_23.png](images/img_23.png)


![img_24.png](images/img_24.png)

![img_25.png](images/img_25.png)

![img_26.png](images/img_26.png)

2阶段的缺点

![img_28.png](images/img_28.png)

# 2pc缺点的解决

单点故障：通过集群的方案来解决
阻塞资源：有阻塞资源就是因为我们在第一个阶段中开启事务后占用资源，在第二个阶段才进行提交或回滚导致，那如果
        我们在第一个阶段直接提交不就可以了嘛，但是那第二个阶段如果要进行回滚该怎么办？其实只要在第一个阶段记住原始数据就好
        seata就是这么对两阶段进行优化的。
数据不一致问题：人工介入

![img_29.png](images/img_29.png)


# 3pc提交协议

![img_30.png](images/img_30.png)

在2阶段的时候，我们第1阶段就会开启事务，占用资源了，但是有可能在第1个阶段就会执行出错，白白占用资源，所以就有3阶段的出现。
在3阶段的时候，我们第一个阶段就会询问是否可以执行，收到请求后并不会执行sql并且不会占用资源，仅仅是判断自己是否可以做，如果可以就返回，在第2个阶段后才会
开始执行sql，占用资源，这个步骤就和2阶段的第一个步骤一样了。

![img_31.png](images/img_31.png)

## can commit执行结果分析

![img_32.png](images/img_32.png)

![img_33.png](images/img_33.png)

如果can commit返回了异常信息
![img_34.png](images/img_34.png)

就会执行abort commit 放弃后续的流程
![img_35.png](images/img_35.png)

## pre commit执行结果分析
![img_36.png](images/img_36.png)

![img_37.png](images/img_37.png)

异常
![img_38.png](images/img_38.png)

异常时需要放弃且回滚，和can commit异常后的处理不同
![img_39.png](images/img_39.png)



## 参与者超时的情况
参与者只在第二阶段和第三阶段超时
![img_41.png](images/img_41.png)

在第二阶段超时直接取消回滚
在do commit阶段超时时会进行提交，因为是一个概率问题，前2个阶段都成功了，大概率第三个阶段会进行提交。

三阶段在实际中运用的不多。
三阶段是对二阶段的一个优化
1.优化了二阶段在第一个步骤出错时的一个资源浪费
2.添加了参与者超时的一个处理机制



#  tcc解决方案

![img_43.png](images/img_43.png)

为什么有TCC？

比如我们有一个redis和一个mysql组合存储的一个业务逻辑方法，
在执行redis时出错了，那么我们怎么回滚redis呢，tcc就可以

![img_44.png](images/img_44.png)

![img_45.png](images/img_45.png)

![img_46.png](images/img_46.png)


# 事件表解决方案

![img_48.png](images/img_48.png)

![img_49.png](images/img_49.png)

将两个大框中分布式服务的事务拆分成4个小的本地事务（1-*，2-*，3-*，4-*）
每个小的事务是完整的，那么整个大事务就是完整的
这个方案的好处就是降低了用户的响应时间RT

# 最大努力通知方案

![img_50.png](images/img_50.png)

![img_51.png](images/img_51.png)














