=====================================监控指标
1.load
load:特定时间间隔内运行队列中的平均线程数
通过top和uptime命令来查看系统的load值。
如果一个线程满足以下条件，该线程就会处于运行队列中
   没有处于I/O等待状态
   没有主动进入等待状态也就是没有调用wait操作
   没有被终止
load值越大，也就意味着系统的CPU越繁忙。一般来说，只要每个CPU当前的线程数不大于3，我们认为它的负载是正常的，
如果每个CPU的线程数大于5，则表示当前系统的负载已经非常高了，需要采取相应的措施来降低系统的负载

2.CPU利用率
CPU的时间消耗主要在这几个方面，即用户进程、内核进程、中断处理、I/O等待、Nice时间、丢失时间、空闲等几个部分。
而CPU的利用率则为这些时间所占总时间的百分比。
可以通过top命令查看Linux系统的CPU消耗情况
top | grep Cpu
对于多个或者多核CPU的情况常常需要查看每个CPU的利用情况，此时可以按1，便可以查看到每个核的CPU利用率
默认情况下top是按照进程来显示CPU的消耗情况的，按“Shift+H键”可以按照线程来查看CPU的消耗情况这一点对于Java
应用来说非常有用

top -p xxxx 参数-p可以指定查看的进程

3.磁盘剩余空间
df -h 查看磁盘的剩余空间，-h表示按单位格式化输出
如果需要查看某个具体目录所占用的空间，分析大文件所处位置，可用使用du命令来进行查看
du -d 1 -h /home/longlong 其中-d参数用来指定递归深度，-h用来进行按文件大小单位的格式化输出

4.网络traffic
通过sar命令，可以看到系统的网络状况
sar -n DEV 1 1 参数-n表示汇报网络状况,而DEV则表示查看是各个网卡的网络流量，第一个1表示每1秒抽样一次，第二个1
   表示总共取1次

5.磁盘I/O
查看系统的I/O状况：
iostat -d -k 参数-d表示查看磁盘使用情况，-k表示以KB为单位显示

6.内存使用
通过free命令，能够查看到系统的内存使用情况，加上-m参数表示以MB为单位
free -m
对于应用来说，更值得关注的应该是虚拟内存swap的消耗，swap内存使用过多，表示物理内存已经不够用了，
操作系统将本应该物理内存存储的一部分内存页调度到磁盘上，以腾出足够的空间给当前的进程使用，当前其他
进程需要运行时，再从磁盘将内存的页调度到物理内存当中，以恢复进程的运行。而这个调度的过程，则会产生
swap I/O，如果swap I/O较为频繁，将严重地影响系统的性能。
通过vmstat命令，可以查看swap I/O的情况

7.qps
qps是query per second的缩写，即每秒查询数。qps在很大程度上代表了系统在业务上的繁忙程度，而每次请求的背后，
可能对应着多次磁盘I/O，多次网络请求，以及多个CPU时间片。


8.rt
rt是response time的缩写，即请求的响应时间


9.select/ps
对于数据库应用来说，单纯的qps或者tps(transaction per second，即每秒事务数)所反映的系统繁忙程度还不够细致，
因为读取数据和写入数据所消耗的资源是不相同的，而对于读多写少或是写多读少的应用采取的优化策略也不尽相同。

10.update/ps、delete/ps

11.GC
在JVM内存分代回收的情况下，对象在JVM内存的新生代Eden区中分配。当Eden区没有足够的空间时虚拟机将发起一次
Minor GC，对内存进行垃圾回收。Minor GC指的是发生在新生代的GC,因为Java对象大多数具备朝生夕死的特征，
因此，Minor GC发生的比较频繁，但一般回收速度比较快。而Major GC，也称为Full GC，指的是发生在老年代的GC,Full GC
的速度则比Minor GC慢得多，因此应用因为GC而停顿的时间也就更长。
