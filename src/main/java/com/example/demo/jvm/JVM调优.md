#JVM参数调优配置

##常见参数配置

-XX:+PrintGC   每次触发GC的时候打印相关日志
-XX:+UseSerialGC  串行回收
-XX:+PrintGCDetails 更详细的GC日志
-Xms   堆初始值
-Xmx   堆最大可用值
-Xmn   新生代堆最大可用值
-XX:SurvivorRatio  用来设置新生代中eden空间和from/to空间的比例 -XX:SurvivorRatio=eden/from=eden/to
-XX:NewRatio=2  设置新生代与老年代比例参数

总结：在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率

##堆内存大小配置
使用示例: -Xmx20m -Xms5m
说明：当下Java应用最大可用内存为20m,初始内存为5m
参见：Test001

##设置新生代比例参数
使用示例：-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC
说明:堆内存初始化值20m,堆内存最大值20m,新生代最大值可用1m,eden空间和from/to空间的比例为2/1
参见：Test002

##设置新生代与老年代的比例参数
使用示例：-Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=2
说明：堆内存初始化值20m,堆内存最大值20m,eden空间和from/to空间的比例为2/1,新生代和老年代的占比为1/2 
参见：Test003

#实战OutOfMemoryError异常

##Java堆溢出 
错误原因：java.lang.OutOfMemoryError:java heap space 对内存溢出
解决办法：设置堆内存大小 //-Xms1m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError
参见：Test004

##虚拟机栈溢出
错误原因：java.lang.StackOverflowError 栈内存溢出
栈溢出产生于递归调用，循环遍历是不会的，但是循环方法里面产生递归调用，也会发生栈溢出
解决办法：设置线程最大调用深度
-Xss5m 设置最大调用深度
###内存溢出与内存泄漏区别
Java内存泄漏就是没有及时清理内存垃圾，导致系统无法再给你提供内存资源（内存资源耗尽）
而Java内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。

## 串行与并行收集器
串行回收：JDK1.5前的默认算法，缺点是只有一个线程，执行垃圾回收时程序停止的时间比较长
并行回收：多个线程执行垃圾回收适合于吞吐量的系统，回收时系统会停止运行

###serial收集器
串行收集器是最古老、最稳定以及效率高的收集器，可能会产品较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收：
新生代赋值算法、老年代标记-压缩；垃圾收集的过程中会Stop the world(服务暂停)

一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。
特点：CPU利用率最高，停顿时间即用户等待时间比较长
适用场景：小型应用
通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器

###ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩
参数控制：-XX:+UseParNewGC  ParNew收集器
-XX:ParallelGCThreads 限制线程数量

###parallel 收集器
Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，
虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；
也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩

采用多线程来通过扫描并压缩堆
特点：停顿时间短，回收效率高，对吞吐量要求高。
适用场景：大型应用，科学计算，大规模数据采集等。
通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

###cms收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 
初始标记（CMS initial mark）
并发标记（CMS concurrent mark）
重新标记（CMS remark）
并发清除（CMS concurrent sweep）
其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 
   由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）
 优点:并发收集、低停顿 
缺点：产生大量空间碎片、并发阶段会降低吞吐量

采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。
（1）初始标记
（2）并发标记
（3）并发预处理
（4）重新标记
（5）并发清除
（6）并发重置
特点：响应时间优先，减少垃圾收集停顿时间
适应场景：大型服务器等。
通过JVM参数 -XX:+UseConcMarkSweepGC设置

###g1收集器
在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
特点：支持很大的堆，高吞吐量
  --支持多CPU和垃圾回收线程
  --在主线程暂停的情况下，使用并行收集
  --在主线程运行的情况下，使用并发收集
实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
通过JVM参数 -XX:+UseG1GC 使用G1垃圾回收器
注意: 并发是指一个处理器同时处理多个任务。 
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 
并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 






通过-XX:UseTLAB设置是否开启TLAB空间，TLAB包含在Eden空间，默认情况下仅占用Eden空间的1%。可以通过-XX:TLABWasteTargetPereent这是TLAB空间所占用Eden空间的百分比大小
，如果在TLAB上分配失败，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存，如果Eden空间无法分配内存，JVM就会执行MinorGC,直至最终可以在Eden空间
分配内存为止（如果时大对象直接在老年代分配）

逃逸分析于栈上分配
java堆区已经不再是对象内存分配的唯一选择，如果希望降低GC的回收频率和提升GC的回收效率，那么则可以使用堆外存储技术。目前最常见的堆外存储技术就是利用i逃逸分析技术筛选出未发生逃逸的
对象，然后避开堆区而直接选择在栈帧中分配内存空间。
逃逸分析（Escape Analysis）时JVM在执行性能优化之前的一种分析技术，它的具体目标就是分析出对象的作用域。简单来说当一个对象被定义在方法体内部之后，它的受访权限仅限于方法体内，一旦
其引用被外部v成员引用后，这个对象就因此发生了逃逸，反之如果定义在方法体内的对象并没有被任何的外部成员引用，JVM就会为其在栈帧中分配内存空间。
由于对象直接在栈上分配内存，因此GC就无须执行垃圾回收。栈帧会伴随着方法的调用而创建，伴随着方法的执行结束而销毁，由此可见，栈上分配的对象所占用的空间将随着栈帧的出栈而释放。
在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析，如果使用的是较早的版本，开发人员可以通过-XX:+DoEscapeAnalysis显示开启逃逸分析，以及通过选项-XX:+PrintEscapeAnalysis查看
逃逸分析的筛选结果











































