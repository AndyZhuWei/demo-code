# MySql数据库中的锁机制

1. ### MySQL锁概述

   - **表级锁**      

     **特点：** 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低 

     **支持的存储引擎：**  MyISAM 、 MEMORY、BDB和 InnoDB 

   - **行级锁**

     **特点:**  开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 

     **支持的存储引擎：**  InnoDB

   - **页面锁** 

     **特点:**   开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 

     **支持的存储引擎：**   BDB 

2. ### MyISAM表锁

   - 两种模式： **表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）** 

   - 写阻塞的和读阻塞的例子

        1**MyISAM存储引擎的写锁阻塞读例子**

        ![**MyISAM存储引擎的写锁阻塞读例子**](http://img.blog.csdn.net/20170419113843041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

        2.**MyISAM存储引擎的读锁阻塞写例子**

        ![**MyISAM存储引擎的读锁阻塞写例子**](http://img.blog.csdn.net/20170517091145402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

        

   - 查询表级锁争用情况

        `show status like 'table%';` 

   ​           `table_locks_waited`    需要等待的表锁数 

   ​           `table_locks_immediate`  立即释放表锁数 

   - 并发插入

      `Lock tables xxx read local, xxx read local;`

      **local:** MyISAM表在满足并发插入条件的情况下，允许其他用户在表尾并发插入记录  

     根据MyISAM的系统变量concurrent_insert，可以控制并发插入行为，其值为0、1和2

     - concurrent_insert为0时，不允许并发插入

     - concurrent_insert为1时，如果MyISAM表中没有空洞，MyISAM允许在一个进程读表的同时，另一个进程从表尾进行插入，这是MySQL的默认设置

     - concurrent_insert为2时，无论是否有空洞，都允许在表尾并发插入记录

       并发插入例子

      可以利用MyISAM存储引擎的并发插入特性，来解决应 用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。 

   - 锁的调度

     ​       mysql会让写进程优先获得锁，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前。所以MyISAM表不太适合有大量更新请求和查询操作应用的原因，也可以通过一些设置来调节

     -  low-priority-updates   使MyISAM引擎默认给予读请求以优先的权利。
     -   SET LOW_PRIORITY_UPDATES=1  使该连接发出的更新请求优先级降低。 
     -  通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级 
     -  max_write_lock_count  设置系统参数，当读锁达到这个值后，MySQL就暂时将写请求的优先级降低。

3. ### InnoDB锁

   与MyISAM最大的不同就是支持事务和采用了行级锁

   > 事务及其ACID属性

   > 并发事务带来的问题

   更新丢失、脏读、不可重复读和幻读

   > 事务隔离级别

   ​       防止更新丢失应该是应用的责任 

   ​       “脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决 。

   数据库实现事务隔离的方式，基本可以分为以下两种

   - 读取数据前进行加锁，阻止其他事务对数据进行修改

   - MVCC（数据多版本并发控制）

     在MVCC中，读操作可以分为两类：快照读和当前读。快照读不需要加锁，读取的是可见版本。当前读，读取的是最新版本，会加锁，防止其他事务进行修改。

     - 快照读

       ` select * from xxx where ?;  ` 简单的sql语句

     - 当前读

        `select * from table where ? lock in share mode;`   S锁

       `select * from table where ? for update;`  X锁 

       `insert into table values (…);`  X锁 

       `update table set ? where ?;`  X锁 

       `delete from table where ?;`  X锁 

    数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一 定程度上 “串行化”进行 。

   ISO/ANSI SQL92定义了4个事务隔离级别

   |                             | 脏读 | 不可重复读 | 幻读 |
   | --------------------------- | ---- | ---------- | ---- |
   | 未提交读(Read uncommitted)  | √    | √          | √    |
   | 已提交读（Read commited）   | ×    | √          | √    |
   | 可重复读（Repeatable read） | ×    | ×          | √    |
   | 可序列化（Serializable）    | ×    | ×          | ×    |

   > 获取InonoDB行锁争用情况

    `show status like 'innodb_row_lock%';` 

   > InnoDB的行锁模式及加锁方法

    InnoDB实现两种类型的行锁：  

    **共享锁（s）:** 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 

    **排他锁（X）** 允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。 <u>*对于没有加锁的简单sql语句是可以直接查询的*</u>

   **意向锁（Intention Locks）** 

​             为了允许行锁和表锁共存，实现多粒度的锁机制，InnoDB内部使用了两种意向锁，这两种意向锁都是表锁

​            **意向共享锁（IS）:**   事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

​            **意向排他锁 （IX）:**    事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。 

|      | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | 冲突 | 冲突 | 冲突 | 冲突 |
| IX   | 冲突 | 兼容 | 冲突 | 兼容 |
| S    | 冲突 | 冲突 | 兼容 | 兼容 |
| IS   | 冲突 | 兼容 | 兼容 | 兼容 |

  如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。 
意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。 
事务可以通过语句显式给记录集加共享锁或排他锁： 

> InnoDB行锁的实现方式

 InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 

 在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。 

![这里写图片描述](http://img.blog.csdn.net/20170419172214144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

使用用索引的表进行试验（其中tab_no_index是有索引键id）

![这里写图片描述](http://img.blog.csdn.net/20170419172837173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。  

![这里写图片描述](http://img.blog.csdn.net/20170420090933646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁 

![这里写图片描述](http://img.blog.csdn.net/20170714163651485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)





 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决 定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突 时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。  

> 间隙锁（Next-Key锁）

 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。 

```
select * from  emp where empid > 100 for update; 
```

比如数据库中有大于100的记录两条101和102 那么不存在的103这条记录就是间隙。

 InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求。

 还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！ 

