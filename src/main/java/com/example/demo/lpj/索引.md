 索引面试题
* 数据库中最常见的慢查询优化方式是什么？
* 为什么加索引能优化慢查询？
* 你知道哪些数据结构可以提高查询速度？
* 那这些数据结构既然都能优化查询速度，MySql为何选择使用B+树？

# MySQL索引
索引是放在磁盘中，是需要持久化的。需要时加载到内存。

##基础知识储备
* 局部性原理
  时间局部性：发现程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分
  空间局部性：最近访问过的程序代码和数据，很快又被访问的可能性很大
* 磁盘预读（预读的长度一般为页（page）的整数倍）
  页是存储器的逻辑块、操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4K），主存和磁盘以
  页为单位交换数据

## 索引是什么
* 索引是帮助MySql高效获取数据的数据结构
* 索引存储在文件系统中
* 索引的文件存储形式与存储引擎有关
* 索引文件的结构
  hash
  二叉树
  B树
  B+树

1 存储引擎：
不同的存储引擎，存方的文件位置和格式都不相同
InnoDB:磁盘
MyISAM:磁盘
memory:内存

不同的存储引擎，数据文件和索引文件存方的位置是不同的，因此有了分类：
聚簇索引：数据和文件放在一起：InnoDB
        .opt 数据库的描述
        .frm 存放的是表结构
        .ibd:存放数据文件和索引文件
非聚簇索引：数据和索引单独一个文件：MyISAM
        .frm 存放的是表结构
        .myi 存方索引数据
        .myd 存方实际数据



show variables like '%per_table%'
```sql
mysql> show variables like '%per_table%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
1 row in set (0.00 sec)

```
如果值为OFF表示，如果你用Innodb的存储时所有的数据文件都会放到一个对应的表空间，而不会为每一个表单独使用文件保存。
如果要修改可以执行
set global innodb_file_per_table=on;


2.索引文件的结构
* hash表(哈希表，散列表)
 hash冲突（高位参与运算 扰动函数）
 哈希表可以完成索引的存储，再添加索引的时候需要计算指定列的hash值，取模后计算出下标，将元素插入下标位置即可
 适合场景：等值查询
         表中的数据是无序数据（范围查找时比较浪费时间，需要挨个进行遍历操作）
         思考：再企业当中多数的查询是等值查询还是范围查询？答案是范围查询，所以此时用hash表不是特别合适
         hash表再使用的时候，需要将全部数据加载到内存中，比较耗费内存空间，也不是很合适
         
* 树
  多叉树
  二叉树
  AVL树
  红黑树
         
树的特点
在树的结构中，左子树小于根节点，右子树必须大于根节点，如果是多叉树的话，从左到右是有序的。

树的发展历程：
多叉树--->二叉树--->AVL树（平衡树）--->红黑树

刚开始有多叉树，但是效率比较低所有就有了二叉树,二叉树二分查找效率比较高。但是二叉树有一个问题就是
容易蜕化成链表，所以就出现了AVL树（平衡树），这个要求左右子树要平衡，左右子树最高和最低的高度差不能超过1，为了
达到这个效果，需要经过1次或多次的旋转了，最后就出现了红黑树。


AVL树是一棵严格意义上的平衡树，最高子树和最低子树的高度差不能超过1，所以在，因此
在进行元素插入的时候，会进行1到N次的旋转，严重影响插入的新能。

红黑树：基于AVL树的一个升级，损失了部分查询性能来提升插入的性能，在红黑树中最低子树
跟最高子树之差小于2倍即可。在插入的时候，不需要进行N多次的旋转操作，而且还加入了变色
的特性，来满足插入和查询性能的平衡。

二叉树及其N多的变种都不能支撑索引，原因是树的深度无法控制或者插入数据的性能比较低。
最后又回到了多叉树

B树=B-树 -不是减少。没有B减树。
B树的本质就是多叉树，一个节点有多个分支

B树的特点：
1.所有的键值都分布在整颗树中
2.搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找
3.每个节点最多拥有m个子树
4.根节点至少有2个子树
5.分支节点至少拥有m/2棵子树（除根节点和叶子节点外都是分支节点）
6.所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列
缺点：
1.每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小
2.当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能

mysql索引结构----B+树
B+Tree是在BTree的基础上做的一种优化，变化如下：
1。B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因
   是将数据范围变为多个区间，区间越多，数据检索越快
2.非叶子节点存储key，叶子节点存储key和数据
3.叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高
注意：
在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有
叶子节点（即数据节点）之间是一种链式环结构，因此可以对B+Tree进行两种查找运算：一种
是对于主键的范围查找和分页查找，另一种是从跟节点开始，进行随机查找。

在oracle或mysql中会自动帮我们给某些列创建索引
第一个是唯一键 第二个是主键



学数据结构可以参考这个网站，很好用
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
https://visualgo.net/en
https://www.geeksforgeeks.org/



 
 注意：
 1.InnoDB是通过B+Tree结构对主键创建索引，然后叶子节点存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，
    那么会生成一个6位的row_id来作为主键
 2.如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，
   然后再通过主键索引找到对应的记录，叫做回表
 
 如果使用的是InnoDB存储引擎在给主键创建索引时叶子节点存储的数据整条数据，
 如果不是给你主键而是非主键的列创建索引时叶子节点中保存的数据则时主键值，此时除了遍历整个普通列的B+Tree结构外，还会根据主键值
 去主键索引的B+Tree中遍历相应的值，相当于遍历了两次B+Tree.这个过程叫做**回表**


如果是MyISAM存储引擎，那么数据文件和索引文件分开存储，
在叶子节点中存储的也不是所有的数据而是一个磁盘文件地址。当找到对应的key时会通过这个地址来查询具体的数据。这个就是和InnoDB主键索引结构的区别


## 索引的分类
* mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过
  给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。
* 主键索引
  主键是一种唯一性索引，但它必须指定为PRIMARY KEY,每个表只能由一个主键
* 唯一索引
   索引列的所有值都只能出现一次，即必须唯一，值可以为空
* 普通索引
   基本的索引类型，值可以为空，没有唯一性的限制（覆盖索引）
* 全文索引
   全文索引的索引类型为FULLTEXT,全文索引可以在varchar、char、text类型的列上创建
* 组合索引
   多列值组成一个索引，专门用于组合搜索（最左匹配原则）



mysql中的自增是通过一个叫做自增锁的来维护的
一般建表没有特殊需求最好设置主键且自增
这样做好处就是在插入数据时索引的叶子节点可以直接往回追加，维护更加容易，不然
可能需要插入中间的叶子节点中，这可能导致**页分裂**。
这个页分裂成本还是很高的，有可能到导致空间浪费，还有可能伴随着页组合，这些都会浪费性能，因为牵扯磁盘IO

唯一索引也不需要回表

覆盖索引
调优的时候需要注意的，有可能的话应该使用覆盖索引。（使用时有局限性）
覆盖索引可以避免回表操作，可以在普通索引中找到的信息则不需要去主键索引中查找。
MyISAM中没有回表的说法

全文索引
MyISAM支持，在InnoDB5.6之后也支持了
一般公司在做检索的时候不会使用了，而是使用es、solr、luceue

百度搜索
倒排索引 pageRank


建立索引的时候还需要考虑列值占用空间的因素


谓词下推


索引下推（index condition pushdown ）简称ICP
在Mysql5.6的版本上推出，用于优化查询。
在回表之前先把数据进行了筛选
例子
```text
导读
本文章始发于本人公众号：码猿技术专栏，原创不易，谢谢关注推荐。
索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。

在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。

在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。

索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

 

开撸
在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。

假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：

　　SELECT * from user where  name like '陈%'
根据 "最佳左前缀" 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。

问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：

　　SELECT * from user where  name like '陈%' and age=20
这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。

 

Mysql5.6之前的版本
5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：



 

会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。

 

Mysql5.6及之后版本
5.6版本添加了索引下推这个优化，执行的过程如下图：



InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，
此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。

 

实践
当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：



根据explain解析结果可以看出Extra的值为Using index condition，表示已经使用了索引下推。

 

总结
索引下推在非主键索引上的优化，可以有效减少回表的次数，大大提升了查询的效率。

关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：

　　set optimizer_switch='index_condition_pushdown=off';

```


## mysql存储引擎
| |MyISAM|InnoDB|
|---|---|---|
|索引类型|非聚簇索引|聚簇索引|
|支持事务|否|是|
|支持表锁|是|是|
|支持行锁|否|是|
|支持外键|否|是|
|支持全文索引|是|是（5.6后支持）|
|适合操作的类型|大量select|大量insert、insert、delete|

事务
事务的隔离性就是通过锁来实现的

默认的存储引擎就是InnoDB

## 索引维护
* 索引在插入新的值的时候，为了维护索引的有序性，必须要维护
 在维护索引的时候需要分以下几种情况：
 1.如果插入一个比较大的值，直接插入即可，几乎没有成本
 2.如果插入的是一个中间的某个值，需要逻辑上移动后续元素的值，空出位置
 3.如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做页分裂，
   此时性能会受影响同时空间的使用率也会降低，除了页分裂之外还包含页合并
*尽量使用自增主键作为索引










