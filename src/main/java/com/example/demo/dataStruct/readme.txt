1.树的查找性能取决于树的高度，让树尽可能平衡，就是为了降低树的高度
2.B树是一种多路搜索树，它的每个节点可以拥有多于两个孩子节点。M路的B树最多能拥有M个孩子节点。
3.为什么会有多路搜索树，就是因为要降低树的高度。那是不是路数越多越好呢？如果是无限路数，那就会退化成一个数组。
B树一般用在文件系统的索引，那为什么不用红黑树或者有序数组呢？
文件系统和数据库的索引都是存在硬盘上的，，并且如果数据量大的话，并不能一次性加载到内存中。这时候B树的多路存储威力就出来了，
可以每次加载B树的一个节点，然后一步一步往下找。如果在内存张，红黑树效率更高，但是涉及到磁盘操作，B树就更优了。
4.B+树：B+树是在B树的基础上进行改造，它的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。为什么要这样设计？
这也和业务场景有关，你想想，数据库中的select数据，不一定只选一条，很多时候会是多条，如果是多条，B树需要做局部的中序遍历，可能要跨层访问。而
B+树由于所有的数据都在叶子节点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。
面试题：
1.既然Hash比B+树更快，为啥还用B+树来存储索引呢？
这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树对索引有序，并且又有链表相连，它的查询效率比hash就快很多了。
而且数据库索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查询效率

======================
1.BitSet:




容器大体上可以分为Map和Collection，其中Collectin又分为List Set 和Queue.
有了List和Set为什么还要Queue，很大程度上是为了高并发做准备的容器，它实现了好多需要在高并发下需要实现的方法
HashTable和Vector自带锁——现在基本不用
紧接着推出了Collections.synchronizedMap()类似的工具类，这个也是加synchronized关键字，虽然加到了方法内部，但是效率也没有提高多高
然后又推出了ConcurrentMap


跳表数据结构
ConcurrentSkipListMap
在每一层上面抽取一些关键元素组成链表，查找的时候从顶层开始查找



