#面试常问
##击穿
前置：肯定发生了高并发
如果有很多客户端，都去访问redis，我们redis是用作缓存，
只要是缓存，就受内存大小限制。
其中的key是有过期时间（LRU、LFU）,再其后边还有DB.
当某个key过期后，有一批流量过来访问它，此时正好没有命中redis，只要去数据，这个就叫做击穿。
其实就是key的过期造成并发访问数据库。

解决方案：
redis是单进程单实例
当所有客户端访问key时不存在，然后让他们再执行setnx()
让第一个执行成功setnx（也就是得到锁的）的去访问数据库
其余没有成功的客户端随机等待一会，再去redis访问key。

总结：
1.get key
2.setnx
3-1.ok，去db
3-2，false sleep -->1

以上的过程的问题：
a.如果第一个上锁的人挂了，没有把过期的key重新设置上。可以设置锁的过期时间
b.第二个问题是没挂，锁超时了.则会由好多人到数据库来查询。多线程。对第一个加锁的线程进行监控，看是否从数据库拿到的结果，如果没有拿到，但是锁快超时了，就把
  锁的时间加一些
分布式协调很麻烦

##穿透 
好多客户端访问redis，redis做缓存用，后边有DB
从业务系统接收查询的是你系统根本不存在的数据
首先是查询redis系统中不存在，然后再db中也不存在。
如果这些请求一直过来则消耗系统资源

解决方案：
a.布隆过滤器
   客户端包含布隆过滤器，这样也redis也到达不了
   客户端包含算法，bitmap再redis中，服务无状态
   redis中集成布隆模块，客户端什么都么有
布隆过滤器只能添加不能删除，可以换布谷鸟过滤器
b.空key


##雪崩
好多客户端访问redis，redis做缓存用，后边有DB
大量key同时失效，间接造成大量的访问达到数据库，会产生雪崩


解决方案：
随机过期时间
   这个也要分情况，有一些情况必须要到某个点造成雪崩（比如零点时必须有一批key要过期，要加载新key）
   还有一些情况与时点性无关的，这种情况把过期时间调整以下就好了
   那零点必须造成雪崩的事情怎么解决？可以强依赖击穿方案
   
##分布式锁
如何使用redis做分布式锁
1.setnx
2.过期时间（在1步加锁的线程挂了，防止死锁）
3.多线程（守护线程） (防止加锁的线程还没有干完事情，锁的时间到了)延长锁过期时间

有现成的框架实现了redis分布式锁，例如
redisson

都已经要上锁了，肯定对速度要求不是很快了，要求的时数据的准确性，一致性。
zookeeper虽然在速度上没有redis快，但是在数据一致性和准确性上要好，而且api也很简单
所以做分布式锁最好用zookeeper

#API
###jedis
线程不安全的，在客户端中可能有多个线程访问同一个jedis创建的连接。解决方案是可以池化jedis的连接

###lettuce
线程安全、支持异步、同步、响应式api

###spring中的使用方式
spring data redis

###spring boot:low/high level
low level:就是拿到redis的连接后进行api调用开发（不易使用，但是更易于灵活控制使用）
high level:提供template进行api进行调用开发（易使用，不易进行灵活控制）



###过程
1.连接
2.使用api
3.数据经过什么编解码，使用什么方式放到redis中的二进制里面


### 临时修改配置文件
config get *  #表示查询当前redis的所有配置信息
其中有一项配置是
163) "protected-mode"
164) "yes"
默认表示禁止远端连接
可以在配置文件中修改也可以临时修改
config set protected-mode no











