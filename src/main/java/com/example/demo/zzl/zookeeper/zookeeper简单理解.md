###为什么要zookeeper
在之前的讲解redis作为缓存有击穿的问题，当时的解决方案就是加锁，让获得锁的线程取后端数据库拿数据在更新到redis中，但就是这个分布式加锁的过程很是麻烦，
也就是做分布式协调这个过程很麻烦（麻烦的点在于加锁的过程中需要方式获得锁的线程挂掉或执行时间过长导致锁失效等一些列问题）
这个时候就需要一个分布式协调框架出现也就是zookeeper，当然了分布式锁对于zookeeper上层应用来说只是其提供功能的冰山一角

从官网学习 https://zookeeper.apache.org/



### 设计目标
####ZooKeeper很简单。
ZooKeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。
名称空间由数据寄存器（在ZooKeeper看来是znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，ZooKeeper数据保留在内存中，
这意味着ZooKeeper可以实现高吞吐量和低延迟数。
ZooKeeper实施对高性能，高可用性，严格有序访问加以重视。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。可靠性方面使它不会成为单点故障。
严格的排序意味着可以在客户端上实现复杂的同步原语

####ZooKeeper已复制。
zookeeper复制说白了也就是通过集群的使用方式，zookeeper是什么集群了模式呢？
说到集群无非就是主从复制集群活着无主集群（redis cluster就是无主集群）【这是从结构说，站在集群的模型上】
要么就是复制（拷贝）的集群，每个节点的东西一样，要么就是分片的集群。无非就是这么两类【站在一推机器中存数据的角度】
zookeeper是有很多进程每个进程上的数据都是一样，所以从这个角度看式复制集群。
从下图也可以看出这个集群有一个leader，其余的是follwer。故是主从集群。
这个模型就和redis是一样的，再主上可以进行读写操作，其余节点只能进行读操作。
这个时候条件反射应该想到一个问题，主是单点，有单点故障，zookeeper是如何解决的呢？（redis是通过哨兵模式，是通过引入一种技术来达到）

而zookeeper本身leader会挂，但是它确实是高可用、及其可靠的。当主挂掉后，集群就会进入无主状态。
所以zookeeper集群有两个运行状态：可用状态和不可用状态（区别在于leader是否挂掉）
如果有一种技术可以快速恢复一个leader，集群就会进入可用状态。（这个技术就是领导者选举技术）
不可用状态恢复到可用状态应该越快越好。
领导者选举算法允许系统恢复得足够快，以防止吞吐量大幅下降。根据我们的观察，ZooKeeper只需不到200毫秒即可选出新的领导者


像它协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。
![zookeeper已复制](https://zookeeper.apache.org/doc/current/images/zkservice.jpg)
组成ZooKeeper服务的服务器都必须彼此了解。它们维护内存中的状态图像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务将可用。

客户端连接到单个ZooKeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。

# 数据模型和分层名称空间
zookeeper是一个目录树结构，里面有节点的概念 即zonode，可以存数据
znode节点存储数据是有大小限制的不超过1M（因为它是一个service,对外要保证该提供协调服务的时候很快，减少网络带宽和数据通信的延迟。这是它的目的），
不要把zookeeper当作数据库使用 影响性能
这个节点也分为持久节点和临时节点。
知识点：每一个client连接到zookeeper节点时会产生一个session，代表整个客户端。整个session有创建和消亡的概念。
依托这个session可以得到一个临时节点的概念。要这个临时节点的目的就是当我这个客户端挂掉后这个临时节点会自动消失，当正常结束后这个临时节点也会正常消失，
这个特性就比之前redis实现分布式锁时需要一个单独线程监控锁超时的方法要方便的多。
不管时持久节点合适临时节点都可以带序号，带序号也就是序列节点

# zookeeper提供的保证
* 顺序一致性——客户端的更新将按发送顺序应用
  如何保证？（由它集群模型——主从模型来决定的）在集群中zookeeper的写都是通过leader单节点，由单节点来实现维护序列时间是很容易的
* 原子性——更新成功或失败，没有部分结果
  如果一个客户端需要创建一个节点A,则zookeeper集群中的所有节点都创建，要不都不创建。
  此时我们要思考要不都创建成功，要不都不创建成功，那么这个就是强一致性，但是zookeeper又是高可用的集群，这和强一致性冲突了，所以
  zookeeper并不是强一致性，而是最终一致性，只要集群由一半写成功，则就是成功了。
* 统一视图——无论服务连接到哪个服务器，客户端都将看到相同的服务器视图
* 可靠性——一旦应用了更新，它将从那时起持续到客户端覆盖更新
* 及时性—— 系统的客户试图保证在特定时间范围内是最新的（表述最终一致性）
  