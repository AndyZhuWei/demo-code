黄俊
#分布式锁
redis红锁


优化
锁细粒度化
缓存
无锁
#分布式id
##基于UUID
UUID长度128bit，32个16进制字符，占用存储空间，且生成的ID是无序的
对于InnoDB这种聚集主键类型的引擎来说，数据会按照主键进行排序，由于UUID的无序性，
InnoDB会产生巨大的IO压力，此时不适合使用UUID做物理主键，可以把它作为逻辑主键，物理主键依然使用自增ID

组成部分：
为了保证UUID的唯一性，规范定义了包括网卡MAC地址，时间戳，名字空间，随机或伪随机数，时序等元素
优点：
性能非常高：本地生成，没有网络消耗
缺点：
不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用
信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄漏，这个泄漏曾被用于寻找
梅丽莎病毒的制作者位置
ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用

##基于DB数据库多种模式（自增模式、segment）

##基于Redis

##基于ZK、ETCD

##基于SnowFlake

##美团Leaf（DB-Segment、zk+SnowFlake）

##百度uid-generator()





KPA架构师不是架构师(KPI+PPT+API)
单机性能没到瓶颈你聊什么分布式和微服务还有云原生？玩呢？KPI呢？钱多？

高并发优化，如何榨干整台服务器？
1.资源锁细粒度化
   比如对一个100的资源，加锁时可以优化为4个锁分别对25个资源加锁
2.业务使用锁细粒度化
  比如写了一个业务逻辑 这个业务逻辑加了一个锁。
  把不需要上锁的代码抽离出来，只对争用资源代码进行上锁。
3.无锁化（真*无锁  假*无锁）
  真*无锁:ThreadLocal
  假*无锁:CAS
4.异步+线程池
  同步：step1--->step2--->step3
  线程池同时执行step1和step2，执行完毕（CompletableFuture）后再执行step3




