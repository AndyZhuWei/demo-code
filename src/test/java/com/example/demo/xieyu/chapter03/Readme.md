##3.3从虚拟机的板块开始
### 3.3.1 HotspotVM板块划分
看默认值的两种方法：
1. 通过jinfo
2. 通过-XX:+PrintFlagsFinal/-XX:+PrintCommandLineFlags来获取 ,
其中-XX:+PrintFlagsFinal是从JDK1.6开始支持的
使用-XX:+PrintFlagsInitial输出真正的默认参数列表，只不过这个默认值并不是系统启动时设置的默认值
查看默认值的例子
```text
java -XX:+PrintFlagsFinal | grep xxx
```
一般Young空间都用-Xmn来设置
Heap总大小使用-Xms来设置它的初始值，使用-Xmx来设置它的上限。在服务器端我们通常将这两个值设置为一样的大，因为
大小的不断调整只是为了给某些客户端程序节省开销，但是对大内存JVM来说就是在“瞎折腾”。
-XX:MinHeapFreeRation GC后剩余空间的百分比小于此值时，JVM的堆内存开始变大，一般输出为40，代表40%
-XX:MaxHeapFreeRation GC后剩余空间的百分比大于此值时，JVM的堆内存开始变小，一般输出为70，代表70%

**Young空间的内在布局**
被分为2个部分、3个版块 即“1个Eden区+2个Survivor区”
Eden区：使用new或newInstance()等方式创建的对象，默认都是先将对象的空间放到Eden区（除非这个对象太大
了Eden区域放不下，或者设定了一个对象阈值-XX:PretenureSizeThreshold,这样对象在分配的时候会直接进入Old区域）

2个Survivor区通常简称为S0、S1,理论上可以认为S0和S1是一样大的，就像“孪生兄弟”一样，当某些动态参数设置后，
这两个区域的大小可能会发生一些改变。

这几个区域是如何配合工作的。
在不断创建对象的过程中，Eden区域会满，满的时候就会开始做Young GC（也称为Minor GC）而Young空间的第1次GC
就是找出“Eden区域活着的对象”，将这些活着的对象向S0或S1其中一个区域存放。

   假设第1次选择了S0,它会逐渐将活着的对象拷贝到S0区域，但是如果S0空间放满了，剩下的活着的对象就只能放在Old区域了。
接下来的动作是直接将Eden区域清空，此时大家应当注意到S1区域是空的。
   第2次Eden区域满的时候，就将“Eden中活着的对象+S0中活着的对象”迁移到S1,迁移方式也是一样的（同样的，如果S1放不下，
对象就会放到Old区域），只是这一次对象来源增加了S0区域的对象，最后被清空的区域是Eden区域和S0区域
   第3次、第4次操作以此类推，细心的你在纸上画一画这个交换过程，就会发现S0和S1始终有一个是空的。
   反反复复多次没有被淘汰的对象也会放入Old区域（也是由一个参数来决定的，但是这个参数的默认值并不一定是许多地方提到
的15）
   
即使Young空间很大，但是活下来的对象是少数的，那么寻找活着的对象就会很快
在Old区域中找活着的对象就要难多了，因为通常大部分对象是活着的，JVM可以设置到10GB甚至更大，此时如果做一次
FULL GC找活着的对象，那么对于性能可想而知。如果系统频繁地发生FULL GC,而这些活着的对象在这么短的时间内被注销
的概率很低，那么FULL GC的时间越长，就会有越多的请求得不到响应或响应很慢，它们所持有的内存就无法释放掉，就会有
越多的对象进入Old区域，这就会在一个“点”上产生一种连锁效应，因此我们写代码时可以多考虑这方面的问题。
   再来看另一个问题。在发生JVM会认为在Old区域的对象很多都应该是活着的，它并不会像Youngk空间那样95%的对象会发生
GC时变成垃圾，所以JVM在设计上不会再给Old区域分配一块像Survivor区一样的区域来存放活着的节点。那么Old区域的对象
清除操作就不能像Eden区域那样。所以它需要在自己的空间内扫描遍历，然后将对于的垃圾对象清除。这个时间开销自然是比较大的，
虽然可以并行，但并行之中又带来了很多冲突的复杂性，因此FULL GC一直都不是我们想看到的GC,我们甚至希望它永远不要发生。

-XX:SurvivorRation=8 Eden/Survivor的区域比重（注意是一个Survivor区的大小）
-XX:InitialSrvivorRation=8 Young/S0的比值结果
这两个参数之一设定后就可以设定两个Survivor区域的大小了，不过，这两个Survior区还会受到-XX:+UseAdaptiveSizePolicy参数
的影响，它会动态调整这两个区域的大小。这个参数在JDK1.6以后默认是开启的。线上一般会关闭这个参数

### 3.3.3 关于永久代
-XX:PermSize
-XX:MAXPermSize
通过工具查看空间使用率来决定设置多大的空间

## 3.4 常见的虚拟机回收算法
### 3.4.1串行GC
  串行GC就是在GC时由单个线程来完成，一般在“Client模式”下这是默认的，或者自己运行时增加：-XX:+UseSerialGC,也就会采用串行GC了
Client模式是32位操作系统的默认值，甚至有些JVM中只有Client或只有Server,具体的需要看JDK安装目录下的子目录jre/bin下面是否存在
一个server目录和client目录，若只存在一个目录，就说明仅仅支持其中一种；如果两个目录都存在，那么在启动时使用java -client或java -server进行选择。
  一般来将，串行GC在单机程序或客户代码中使用，对于小内存程序（官方推荐是小于100MB）,且CPU个数很有限，用串行GC其实是明智的选择。
  上面提到的Old区域，在串行GC模式下也叫做Tenured,因为串行GC对Old区域回收的算法名就叫Tenured
  面对较大的内存，如果仅仅针对Young空间的回收也许用串行GC就可以满足需求（因为Young孔金活着的都是少数），但如果发生FULL GC,那么串行回收的效率是
远远不够的。因此希望将回收操作并行、并发起来，面对大内存这样操作，对于多线程的分配开销通常是值得的。
### 3.4.2 ParallelGC与ParallelOldGC
  如果系统启动默认设置了-server参数，那么就默认使用-XX:+UseParallelGC参数，在64位模式下的JVM和OS中，默认也会使用-server参数。
还有一个-XX:+UseParallelOldGC参数（在JDK1.6后出现的参数），都是并行GC.
  它与串行搜集器其实是类似的，最重要的区别在于它是用多线程来处理的。
  通过增加参数-XX:+PrintGCDetails来看看他们对Young空间、Old空间、Perm空间分别采用了什么方法来做GC
  PSYoungGen是针对Young空间来讲的，也就是“并行清除”的意思（Parallel Scavenge）,它讲究“吞吐量”，尽量增加平均每段时间内对外提供服务的时间。但是
并不会像并发GC(CMS)那样考虑用户访问的尽量不暂停，也许它会暂停一会儿，但是它对于整体时间来讲，服务时间更多
  在设置了-XX:+UseParallelGC参数的情况下，可以通过-XX:MaxGCPauseMillis参数来设置最多的暂停时间，也可以通过-XX:GCTimeRtion参数来设置GC时间
的比例

  JVM并行GC的一个小“悲观策略”
  在并行GC中，如果有对象晋升到Old空间，则会记录每次晋升对象的大小，也会在晋升后计算Old区域剩余的空间大小，如果这次Minor GC顺利完成，即使Old
区域还可能会剩余空间，但是如果JVM发现Old区域剩余的空间已经不能承载“每次晋升对象的平均大小”时，它会再做一次FULL GC尝试释放内存。换句话说，就是这个
时候根本还没有满，但是做了FULL GC

**总结**
通过本节了解到，在并行GC下最少有两种情况会导致Full GC
1. Old区域慢的时候（确切地说，是要晋升的对象大于Old区域剩余的空间）
2. Old区域的剩余空间已经小于平均晋升空间的大小的时候
另外，还有一些情况可能会导致FULL GC
3. Perm区域满的时候也会导致FULL GC
4. 系统中使用System.gc()的时候也会默认导致FULL GC,这样的FULL GC在日志中可以清晰看到关键字（system）。设置-XX:+DisableExplicitGC
参数后，代码中的System.gc()就不再生效了
5. dump内存的时候，例如：通过jmap等工具来dump内存的时候，也同样会先发生一次FULL GC再开始dump
### 3.4.3 CMS GC与未来的G1
CMS GC又称为并发GC,Concurrent Mark Sweep并发标记、清除的意思。
对于1GB、1.5GB、2GB的JVM内存，如果代码没有问题，那么GC的开销时间并不多（当然不会和C语言比较微妙、纳秒的效率）；如果采用了并行搜集，那么每次GC
基本在毫秒级可以处理完，这对于传统的Web应用来将基本足够，因为用户感知是在秒级别的。
当有一个遇到内存达到10GB、100GB的时候，就遇到了麻烦，GC的暂停时间将会十分恐怖，可能会是10s\20s\100s以上。那么Java就与大内存无缘了吗？
我们有一种“土办法”，但是很管用，就是将一个大内存的机器划分为多个虚拟机或者启动多个JVM实例来实现大内存的使用，两种方法都可以达到目的，实现节约成本，
而且效果不错。
多实例方式的效率通常高于虚拟机，但是多实例部署时会存在大量端口的修改，比较麻烦，而且资源隔离性，虚拟机会更好一些，所以在应用部署上通常选择虚拟机
划分方式。
但这种“土办法”对于一些单个实例需要大内存计算的应用背景不适合，土办法变得真的有点土了。CMS的存在就是为大内存做了一个伟大的铺垫
CMS GC七个步骤基本动作
1. CMS-initial-mark ,单线程处理环节，并且会完全暂停JVM,找到所有的root根，将root根所引用的对象标记在一个BitMap中。此时业务恢复正常，
GC进入到下一个步骤
2. CMS-concurrent-mark,根据第1个步骤对记录在BitMap中的信息进行并发标记对象。此时JVM内所允许的程序不会暂停
3. CMS-concurrent-preclean,处理Young与Old之间的引用，尽量将可能的引用梳理出来，节约remark的时间
4. CMS-concurrent-abortable-preclean
5. CMS-remark,JVM全暂停的第2个阶段，由于前面几个步骤中存在业务的并发，所以会导致一些“脏”数据。remark是来解决这个问题的。因此这个阶段也会全部暂停，
但是它不是再用root开始遍历，而是根据一个“卡表”，换句话说，卡表中有我们想要的“脏”块信息。
6.CMS-concurrent-sweept,不停机，单线程操作，按照内存的地址顺序遍历Old\Perm区域，根据bitmap中的记录，对垃圾内存进行清除操作。
7.CMS-concurrent-reset.

使用CMS GC，一般是使用-XX:+UseConcMarkSweepGC来启用GC.启用该参数后，它将默认对Young空间启用算法：ParNew,相当于设置了-XX:+UseParNewGC参数

G1:将Java堆划分为多个较小且大小相同的内存板块（region）.它也有分代，在region里分代，运行过程中会维护一个优先级列表，这个优先级列表其实是按照垃圾多少
来排序的，这样垃圾最多的region就是最前面一个板块，每次就回收这个垃圾最多的板块

### 3.4.4 简单总结
串行GC用在CPU数量少，内存小的应用中。例如本地开发、手机客户端、串行GC是不错的选择，在Client模式下是启用的
在普通的服务器应用中使用1~2GB的JVM节点较为常见，推荐启用-XX:+UseParallelOldGC参数，设置后就不需要再设置-XX:+UseParallelGC参数了
最后，谈到了CMS GC是大内存时代的一个铺垫以及未来的G1

通过上面介绍我们可以发现，不论是何种GC方式，都希望在业务待中尽量地使用“小而美”的内存
1.“小”，是指程序中所申请的对象不是那么大，没有特殊的用途，不去申请一个特别大的内存空间。
2.“美” 我们希望它像昙花一样美丽，它不在乎永久，只在乎增经拥有，它给这个世界带来没，干净利落，就是美的象征

## 3.5 浅析Java对象的内存结构
### 3.5.1 原始类型与对象的自动拆装箱

















